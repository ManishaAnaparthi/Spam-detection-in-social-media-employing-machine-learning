# -*- coding: utf-8 -*-
"""Detect Phishing in Youtube Comment URLs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k6I_0pFdMP3TY-K5FfaxS0B4uD8EP2n8
"""

# Commented out IPython magic to ensure Python compatibility.
#importing numpy and pandas which are required for data pre-processing
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline

#Loading the data
raw_data = pd.read_csv("/content/dataset2.csv")

raw_data.head()

"""**We need to split the data according to parts of the URL* *italicised text*


# **A typical URL could have the form http://www.example.com/index.html, which indicates a protocol (http), a hostname (www.example.com), and a file name (index.html).**
"""

raw_data['URL'].str.split("://").head() #Here we divided the protocol from the entire URL. but need it to be divided it 
                                                 #seperate column

seperation_of_protocol = raw_data['URL'].str.split("://",expand = True) #expand argument in the split method will give you a new column

seperation_of_protocol.head()

type(seperation_of_protocol)

seperation_domain_name = seperation_of_protocol[1].str.split("/",1,expand = True) #split(seperator,no of splits according to seperator(delimiter),expand)

type(seperation_domain_name)

seperation_domain_name.columns=["domain_name","address"] #renaming columns of data frame
seperation_domain_name.head()

#Concatenation of data frames
splitted_data = pd.concat([seperation_of_protocol[0],seperation_domain_name],axis=1)
splitted_data.columns = ['protocol','domain_name','address']
splitted_data.head()

splitted_data['is_phished'] = pd.Series(raw_data['Target'], index=splitted_data.index)
splitted_data

"""# **Features Extraction**
Feature-1

1.Long URL to Hide the Suspicious Part

# ***If the length of the URL is greater than or equal 54 characters then the URL classified as phishing***

0 --- indicates legitimate

1 --- indicates Phishing

2 --- indicates Suspicious 
"""

def long_url(l):
    l= str(l)
    """This function is defined in order to differntiate website based on the length of the URL"""
    if len(l) < 54:
        return 0
    elif len(l) >= 54 and len(l) <= 75:
        return 2
    return 1
#Applying the above defined function in order to divide the websites into 3 categories
splitted_data['long_url'] = raw_data['URL'].apply(long_url) 
#Will show the results only the websites which are legitimate according to above condition as 0 is legitimate website
splitted_data[splitted_data.long_url == 0]

"""
Feature-2

# **2.URL’s having “@” Symbol**

Using “@” symbol in the URL leads the browser to ignore everything preceding the “@” symbol and the real address often follows the “@” symbol.

IF {Url Having @ Symbol→ Phishing Otherwise→ Legitimate }

0 --- indicates legitimate

# 1 --- indicates Phishing"""

def have_at_symbol(l):
    """This function is used to check whether the URL contains @ symbol or not"""
    if "@" in str(l):
        return 1
    return 0
    
splitted_data['having_@_symbol'] = raw_data['URL'].apply(have_at_symbol)
splitted_data

"""### 3.Redirecting using “//”

The existence of “//” within the URL path means that the user will be redirected to another website. 
# **An example of such URL’s is: “http://www.legitimate.com//http://www.phishing.com”**. 
We examine the location where the “//” appears. We find that if the URL starts with “HTTP”, that means the “//” should appear in the sixth position. However, if the URL employs “HTTPS” then the “//” should appear in seventh position.

IF {ThePosition of the Last Occurrence of "//" in the URL > 7→ Phishing

Otherwise→ Legitimate

0 --- indicates legitimate

1 --- indicates Phishing 
"""

def redirection(l):
    """If the url has symbol(//) after protocol then such URL is to be classified as phishing """
    if "//" in str(l):
        return 1
    return 0
splitted_data['redirection_//_symbol'] = seperation_of_protocol[1].apply(redirection)
splitted_data.head()

#legit = len(pd[pd['Result'] == 1])
susp = len(pd[pd['Result'] == 0])
phishy = len(pd[pd['Result'] == 2])

size=[legit, susp, phishy]
names = ['Legitimate', 'Suspicious', 'Phishy']
 
# Create a circle for the center of the plot
my_circle=plt.Circle( (0,0), 0.7, color='white')

plt.pie(size, labels=names, colors=['blue','pink','red'])
p=plt.gcf()
p.gca().add_artist(my_circle)
plt.rcParams["figure.figsize"] = (5,5)
plt.title('Class Distribution')
plt.show()

